package bio.terra.pearl.core.service.participant;

import bio.terra.pearl.core.service.exception.internal.InternalServerException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.ClassPathResource;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.io.FileInputStream;
import java.io.InputStream;
import java.util.HashSet;
import java.util.Optional;
import java.util.Scanner;
import java.util.Set;
import java.util.function.Function;

@Service
@Slf4j
public class ShortcodeService {
    public static final String SHORTCODE_ALLOWED_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    public static final int SHORTCODE_LENGTH = 6;
    public static final String PROFANITY_LIST_PATH = "profanity/bannedWords.txt";

    private final RandomUtilService randomUtilService;
    private Set<String> profanityList;

    public ShortcodeService(RandomUtilService randomUtilService) {
        this.randomUtilService = randomUtilService;
        this.profanityList = loadProfanityList();
    }

    public Set<String> loadProfanityList() {
        ClassPathResource resource = new ClassPathResource(PROFANITY_LIST_PATH);
        profanityList = new HashSet<>();
        try (InputStream bannedWordsStream = resource.getInputStream();
             Scanner scanner = new Scanner(bannedWordsStream)) {
            while (scanner.hasNextLine()) {
                profanityList.add(scanner.nextLine().trim());
            }
        } catch (Exception e) {
            // Log this as an error, but don't treat it as fatal.
            // return an empty set so that we can continue generating shortcodes
            log.error("Unable to load banned words file. Shortcodes will still be generated, but may contain profanity.", e);
            return Set.of();
        }
        return profanityList;
    }

    //this is pretty naively implemented, but it's fine for now
    public boolean isShortcodeBanned(String possibleShortcode) {
        for (String word : profanityList) {
            if (possibleShortcode.toLowerCase().contains(word.toLowerCase())) {
                return true;
            }
        }
        return false;
    }

    /**
     * Generate a unique shortcode. The shortcode is generated by concatenating the prefix with a random string.
     * It's possible there are snazzier ways to get postgres to generate this for us,
     * but for now, just keep trying strings until we get a unique one.
     * throws InternalServerException if, after 10 tries, a shortcode still couldn't be found.
     */
    @Transactional
    public <T> String generateShortcode(String prefix, Function<String, Optional<T>> findOneByShortcode) {
        final int MAX_TRIES = 10;
        for (int tryNum = 0; tryNum < MAX_TRIES; tryNum++) {
            String possibleShortcode = randomUtilService.generateSecureRandomString(SHORTCODE_LENGTH, SHORTCODE_ALLOWED_CHARS);

            if (isShortcodeBanned(possibleShortcode)) {
                log.info("Attempted to generate banned shortcode {} on retry attempt {}", possibleShortcode, tryNum);
                continue;
            }

            if (prefix != null && !prefix.isEmpty()) {
                possibleShortcode = prefix + "_" + possibleShortcode;
            }

            if (findOneByShortcode.apply(possibleShortcode).isEmpty()) {
                return possibleShortcode;
            }
        }
        throw new InternalServerException("Unable to generate unique shortcode");
    }
}

